<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>数学 フラッシュカード</title>

  <style>
    :root{
      --bg:#0f172a; --panel:#0a0f1a; --card:#0b1220;
      --border:#1f2937; --fg:#e5e7eb; --muted:#9ca3af;
      --acc:#22d3ee; --answer:#7CFFB2;
    }
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,
        "Hiragino Kaku Gothic ProN",Meiryo,sans-serif;
      line-height:1.7;
      background:
        linear-gradient(rgba(5,8,20,.75), rgba(5,8,20,.9)),
        url("../img/bg_fc_enExamples.png");
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
      background-attachment:fixed;
      color:var(--fg);
    }
    .page{
      min-height:100vh;
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:80px 16px 24px;
      box-sizing:border-box;
    }
    .topbar{
      position:fixed;
      top:0; left:0; right:0;
      z-index:10;
      padding:8px 16px;
      display:flex;
      justify-content:center;
      background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(15,23,42,.4) 60%, transparent);
      backdrop-filter: blur(6px);
    }
    .topbar-inner{
      width:min(960px,96vw);
      display:flex;
      align-items:center;
      gap:14px;
      flex-wrap:wrap;
    }
    .topbar-inner .spacer{flex:1;}
    .app-title{
      font-size: clamp(18px,3.6vw,22px);
      font-weight: 800;
      letter-spacing: 0.02em;
    }
    .back-link{
      display:inline-flex;
      align-items:center;
      gap:6px;
      text-decoration:none;
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.85rem;
      font-weight: 700;
      background: #0a1322;
    }
    .back-link:hover{ border-color:#2b3a55; }

    .flashcard{
      width: min(960px, 96vw);
      background: linear-gradient(180deg,#0a1322,#0a0f1a);
      border-radius: 0.9rem;
      padding: 1.2rem 1.4rem 1.8rem;
      border: 1px solid var(--border);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
      cursor: pointer;
      user-select: none;
      position:relative;
    }

    .category-row{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom:6px;
    }
    .category-label{
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: var(--muted);
      text-transform: uppercase;
    }
    .category-name{
      font-size: clamp(16px,3.2vw,20px);
      font-weight: 800;
      letter-spacing: 0.01em;
      color: var(--fg);
      text-align: left;
    }
    .category-count{ font-size:0.85rem; color:var(--muted); }
    .progress{ font-size:0.85rem; color:var(--muted); }
    .category-spacer{ flex:1; }

    .card-title { display:none; }

    .qa{
      min-height: 120px;
      white-space: normal;
      font-size: clamp(18px,3.6vw,24px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .card-face{ width:100%; display:inline-block; }

    .card-answer{
      margin-top: 0.75rem;
      padding-top: 0.6rem;
      border-top: 1px dashed var(--border);
      color: var(--answer);
      transition: opacity 0.15s ease;
    }
    .card-answer.is-hidden{
      color: transparent;
      border-color: transparent;
    }

    .exp-corner{
      position:absolute;
      right:18px;
      bottom:16px;
      font-size:0.85rem;
      color:var(--muted);
    }

    @media (min-width: 768px) {
      .page { padding: 96px 16px 32px; }
    }
  </style>

  <!-- MathJax 設定 -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] },
      svg: { fontCache: "global" }
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="app-title">数学 フラッシュカード</div>
      <div class="spacer"></div>
      <a class="back-link" href="../index.html" aria-label="戻る">← 戻る</a>
    </div>
  </div>

  <div class="page">
    <section class="flashcard" id="flashcard">
      <div class="category-row" aria-label="カテゴリ">
        <div class="category-label">カテゴリ</div>
        <div id="categoryLabel" class="category-name">数学</div>
        <div id="totalCount" class="category-count">全0問</div>
        <div class="category-spacer"></div>
        <button id="randomBtn" type="button">切り替え</button>
        <div id="countLabel" class="progress">0 / 0</div>
      </div>

      <div class="card-title" id="problemTitle">第1問</div>

      <div class="qa">
        <div class="card-face" id="problemQuestion"></div>
        <div class="card-face card-answer is-hidden" id="problemAnswer"></div>
      </div>

      <div class="exp-corner">EXP: <span id="expLabel">0</span></div>
    </section>
  </div>

  <script>
    // ---------- EXP ----------
    const EXP_KEY = "midunohi.exam.exp";
    let exp = 0;

    const expDisplayEl = document.getElementById("expLabel");
    const countLabelEl = document.getElementById("countLabel");
    const totalCountEl = document.getElementById("totalCount");

    function loadExp() {
      try {
        const stored = localStorage.getItem(EXP_KEY);
        if (stored == null) exp = 0;
        else {
          const n = Number(stored);
          exp = Number.isFinite(n) && n >= 0 ? Math.floor(n) : 0;
        }
      } catch (e) {
        console.warn("EXP を読み込めませんでした", e);
        exp = 0;
      }
      updateExpDisplay();
    }

    function saveExp() {
      try {
        localStorage.setItem(EXP_KEY, String(exp));
      } catch (e) {
        console.warn("EXP を保存できませんでした", e);
      }
      updateExpDisplay();
    }

    function updateExpDisplay() {
      if (expDisplayEl) expDisplayEl.textContent = String(exp);
    }

    // ---------- Problems ----------
    let problems = [];
    let currentCategory = "--";
    let currentFileIndex = -1;

    const problemTitleEl = document.getElementById("problemTitle");
    const problemQuestionEl = document.getElementById("problemQuestion");
    const problemAnswerEl = document.getElementById("problemAnswer");
    const flashcardEl = document.getElementById("flashcard");
    const randomBtnEl = document.getElementById("randomBtn");
    const categoryLabelEl = document.getElementById("categoryLabel");

    let currentIndex = 0;
    let showingAnswer = false;
    let cycleCount = 0;
    let busy = false;
    let lastIndex = -1;
    let answeredCount = 0;
    let filesCache = null;

    function pickRandomIndex(len, except) {
      if (len <= 1) return 0;
      let i = 0;
      do { i = Math.floor(Math.random() * len); } while (i === except);
      return i;
    }

    // ---------- MathJax helpers ----------
    function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function waitForMathJax(maxMs = 5000) {
      const t0 = performance.now();
      while (performance.now() - t0 < maxMs) {
        const mj = window.MathJax;
        if (mj && mj.typesetPromise && mj.startup && mj.startup.promise) {
          await mj.startup.promise; // 完全起動待ち
          return mj;
        }
        await delay(25);
      }
      return null; // MathJax来ない場合も落ちないようにする
    }

    async function typesetElements(els) {
      const mj = await waitForMathJax();
      if (!mj) return; // MathJax未到着なら素表示で進む
      if (mj.typesetClear) mj.typesetClear(els);
      await mj.typesetPromise(els);
    }

    // ---------- Render ----------
    function normalizeProblem(p, index) {
      if (Array.isArray(p)) {
        return {
          title: `第${index + 1}問`,
          question: String(p[0] ?? ""),
          answer: String(p[1] ?? "")
        };
      }
      if (p && typeof p === "object") {
        const question = p.question ?? p.q ?? "";
        const answer = p.answer ?? p.a ?? "";
        const title = p.title ?? `第${index + 1}問`;
        return {
          title: String(title),
          question: String(question),
          answer: String(answer)
        };
      }
      return { title: `第${index + 1}問`, question: "", answer: "" };
    }

    async function renderProblem() {
      const p = normalizeProblem(problems[currentIndex], currentIndex);

      // まず普通に表示（MathJax待ちの間も文字が出る）
      problemTitleEl.textContent = p.title;
      problemQuestionEl.innerHTML = p.question;
      problemAnswerEl.innerHTML = p.answer;

      problemAnswerEl.classList.add("is-hidden");
      showingAnswer = false;

      if (totalCountEl) totalCountEl.textContent = `全${problems.length}問`;
      if (countLabelEl) countLabelEl.textContent = `${cycleCount} / 10`;

      // その後にMathJaxで整える（準備できた時点で反映）
      await typesetElements([problemQuestionEl, problemAnswerEl]);
    }

    function toCards(raw) {
      if (!Array.isArray(raw)) return [];
      return raw.map((row, i) => {
        if (Array.isArray(row)) {
          const [question, answer] = row;
          return { title: `第${i + 1}問`, question, answer };
        }
        if (row && typeof row === "object") {
          return {
            title: row.title ?? `第${i + 1}問`,
            question: row.question ?? row.q ?? "",
            answer: row.answer ?? row.a ?? ""
          };
        }
        return { title: `第${i + 1}問`, question: "", answer: "" };
      }).filter(c => c.question || c.answer);
    }

    async function loadFilesList() {
      if (filesCache) return filesCache;
      const res = await fetch("../qa_math/files.json", { cache: "no-store" });
      if (!res.ok) throw new Error("qa_math/files.json を読み込めませんでした");
      const data = await res.json();
      filesCache = Array.isArray(data) ? data : [];
      return filesCache;
    }

    async function loadCategory(name) {
      const base = String(name || "").replace(/\.json$/i, "");
      const url = encodeURI(`../qa_math/${base}.json`);
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`qa_math/${base}.json を読み込めませんでした`);
      const raw = await res.json();
      const data = toCards(raw);
      if (!data.length) throw new Error(`qa_math/${base}.json にカードがありません`);
      problems = data;
      currentCategory = base;
      answeredCount = 0;
      cycleCount = 0;
      lastIndex = -1;
      updateRandomButton();
      await showRandomProblem(-1);
    }

    async function loadRandomCategory(exceptIndex = -1) {
      const files = await loadFilesList();
      if (!files.length) throw new Error("qa_math/files.json にカテゴリがありません");
      const idx = pickRandomIndex(files.length, exceptIndex);
      await loadCategory(files[idx]);
      currentFileIndex = idx;
      return idx;
    }

    function updateRandomButton() {
      if (randomBtnEl) randomBtnEl.textContent = "切り替え";
      if (categoryLabelEl) categoryLabelEl.textContent = currentCategory;
    }

    async function showRandomProblem(exceptIndex = -1) {
      if (!problems.length) {
        problemQuestionEl.textContent = "(カードが読み込まれていません)";
        problemAnswerEl.textContent = "";
        problemAnswerEl.classList.add("is-hidden");
        if (countLabelEl) countLabelEl.textContent = "0 / 10";
        if (totalCountEl) totalCountEl.textContent = "全0問";
        return;
      }
      currentIndex = pickRandomIndex(problems.length, exceptIndex);
      cycleCount = Math.min(cycleCount + 1, 10);
      await renderProblem();
    }

    // ---------- Self test ----------
    function runSelfTests() {
      console.assert(Array.isArray(problems), "problems は配列である必要があります");
      console.assert(problems.length >= 1, "少なくとも 1 問は登録してください");
      problems.forEach((p, i) => {
        const n = normalizeProblem(p, i);
        console.assert(typeof n.title === "string" && n.title.length > 0, `問題${i + 1} に title が必要です`);
        console.assert(typeof n.question === "string" && n.question.length > 0, `問題${i + 1} に question が必要です`);
        console.assert(typeof n.answer === "string" && n.answer.length > 0, `問題${i + 1} に answer が必要です`);
      });
      console.assert(typeof exp === "number", "exp は数値である必要があります");
    }

    // ---------- Click behavior ----------
    flashcardEl.addEventListener("click", async () => {
      if (busy) return;
      busy = true;
      try {
        if (!showingAnswer) {
          problemAnswerEl.classList.remove("is-hidden");
          showingAnswer = true;
          await typesetElements([problemAnswerEl]);
        } else {
          exp += 1;
          saveExp();
          answeredCount += 1;

          if (answeredCount % 10 === 0) {
            try {
              currentFileIndex = await loadRandomCategory(currentFileIndex);
            } catch (err) {
              console.error(err);
            }
          } else {
            lastIndex = currentIndex;
            await showRandomProblem(currentIndex);
          }
        }
      } finally {
        busy = false;
      }
    });

    // ---------- Boot ----------
    (async () => {
      loadExp();
      try {
        updateRandomButton();
        await loadRandomCategory(-1);
        runSelfTests();
      } catch (e) {
        console.error(e);
        problemQuestionEl.textContent = "カード一覧の読み込みに失敗しました";
        problemAnswerEl.textContent = "qa_math/files.json と qa_math/*.json を確認してください";
        problemAnswerEl.classList.remove("is-hidden");
        if (countLabelEl) countLabelEl.textContent = "0 / 0";
      }
    })();

    let lastFileIndex = -1;
    if (randomBtnEl) {
      randomBtnEl.addEventListener("click", async (e) => {
        e.stopPropagation();
        try {
          lastFileIndex = await loadRandomCategory(lastFileIndex);
        } catch (err) {
          console.error(err);
        }
      });
    }
  </script>
</body>
</html>
