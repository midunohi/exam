<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>„É¢„É≥„Çπ„Çø„ÉºÁã©„Çä Ëã±ÂçòË™û</title>
<style>
  :root{
  --bg:#020617;
  --ok:#22c55e;
  --bad:#ef4444;
  --q-size: clamp(22px, 1.8vw + 14px, 30px);
  --choice-size: clamp(20px, 1.6vw + 14px, 28px);
  --choice-min-h: clamp(52px, 6vh, 72px);
  --next-size: clamp(16px, 1.2vw + 12px, 22px);
  --next-pad-y: clamp(10px, 1.2vh, 16px);
  --next-pad-x: clamp(16px, 2vw, 26px);
  --next-h: clamp(52px, 6vh, 70px);
}

@media (orientation: portrait){
  :root{
    --q-size: clamp(26px, 3.6vw + 12px, 38px);
    --choice-size: clamp(24px, 3.2vw + 12px, 36px);
    --choice-min-h: clamp(60px, 10vh, 90px);
    --next-size: clamp(20px, 2.6vw + 12px, 28px);
    --next-pad-y: clamp(12px, 2vh, 18px);
    --next-pad-x: clamp(20px, 4vw, 32px);
    --next-h: clamp(62px, 9vh, 88px);
  }
}
  *{box-sizing:border-box}
  html,body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;
    background:#0b1a33 url('img/bg_rpg_field.png') no-repeat center top/cover;
    color:#fff;
  }

  #wrap{min-height:100vh;display:grid;grid-template-rows:auto minmax(0,1fr) auto;gap:8px;padding:8px}
  #topGrid{display:grid;grid-template-columns:minmax(0,1.1fr) minmax(0,1fr);grid-template-rows:auto minmax(0,1fr);gap:8px;align-items:start}
  .panel{background:none;border-radius:0;padding:0}
  .compact{font-size:14px;line-height:1.3}
  .row{display:flex;align-items:center;gap:6px;margin-bottom:4px}
  .row .label{opacity:.8}
  .bar{flex:1;height:12px;border-radius:999px;overflow:hidden;background:#020617}
  .bar>span{display:block;height:100%;width:0;transition:width .2s}
  .hp>span{background:linear-gradient(90deg,#ef4444,#b91c1c)}
  .exp>span{background:linear-gradient(90deg,#38bdf8,#0ea5e9)}
  .val{min-width:90px;text-align:right;opacity:.9;font-size:12px}

  /* QA: ÈöôÈñì„ÇíÂüã„ÇÅ„Çã */
  #qaBox{display:flex;flex-direction:column;min-height:34vh}
  #question{margin:0 0 8px;font-size:var(--q-size);font-weight:700}
  #choices{flex:1;display:flex;flex-direction:column;gap:4px;min-height:0}

  button.choice{
    flex:1;
    min-height:var(--choice-min-h);
    padding:12px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(17,24,39,.86);
    color:inherit;
    font-size:var(--choice-size);
    font-weight:700;
    cursor:pointer;
  }
  button.choice:disabled{opacity:.55;cursor:default}
  button.choice.correct{background:rgba(34,197,94,.28);border-color:rgba(34,197,94,.9)}
  button.choice.wrong{background:rgba(239,68,68,.28);border-color:rgba(239,68,68,.9)}

  #logWrap{min-height:96px;max-height:30vh;display:flex;flex-direction:column;padding-top:2px;background:rgba(0,0,0,.35);border-radius:8px}
  #log{flex:1;overflow:auto;font-size:13px;padding:4px 6px}
  #log p{margin:2px 0}
  .ok{color:var(--ok)}
  .bad{color:var(--bad)}
  .blink{animation:blink .24s 3}
  @keyframes blink{50%{filter:brightness(2)}}

  #enemyView img{display:block;width:100%;height:auto;max-height:30vh;object-fit:contain;opacity:.95}
</style>
</head>
<body>
<div id="wrap">
  <div id="topGrid">
    <section id="heroBox" class="panel compact">
      <div class="row"><span class="label">Lv</span><span id="lv">1</span></div>
      <div class="row"><span class="label">EXP</span><div class="bar exp"><span id="expBar"></span></div><span class="val" id="expText">0 / 20</span></div>
      <div class="row"><span class="label">HP</span><div class="bar hp"><span id="hpBar"></span></div><span class="val" id="hpText">30 / 30</span></div>
      <div class="row"><span class="label">ATK</span><span id="atk">5</span></div>
    </section>

    <section id="enemyBox" class="panel compact">
      <div class="row"><span class="label">ENEMY</span><span id="enemyName">‚Äî</span></div>
      <div class="row"><span class="label">HP</span><div class="bar hp"><span id="enemyHpBar"></span></div><span class="val" id="enemyHpText">0 / 0</span></div>
    </section>

    <section id="qaBox" class="panel">
      <p id="question">‚Äî</p>
      <div id="choices"></div>
    </section>

    <section id="enemyView" class="panel">
      <img id="enemyImg" src="" alt="" onerror="this.style.display='none'" />
    </section>
  </div>

  <section id="logWrap" class="panel">
    <div id="log"></div>
  </section>
</div>

<script>
const $=id=>document.getElementById(id);
const KEY='midunohi.exam.exp'; // Á¥ØË®àEXP
const R=n=>(Math.random()*n)|0;
const clamp=(x,a,b)=>x<a?a:x>b?b:x;
const bar=(id,r)=>{const e=$(id); if(e) e.style.width=(100*clamp(r,0,1)).toFixed(1)+'%';};
const log=s=>{const e=$('log'); if(!e) return; e.insertAdjacentHTML('beforeend',`<p>${s}</p>`); e.scrollTop=e.scrollHeight;};
const clearLog=()=>{const e=$('log'); if(e) e.innerHTML='';};

// ---- EXPÊõ≤Á∑öÔºà„Åì„Åì„Å†„ÅëÂ•Ω„Åø„ÅßË™øÊï¥Ôºâ ----
const EXP0 = 20;         // Lv1->2 ÂøÖË¶ÅEXP
const EXP_GROW = 1.35;   // ÂøÖË¶ÅEXPÊàêÈï∑Áéá

// fallback
const FALLBACK_WORDS=[
  {en:'increase',ja:'Â¢ó„Åà„Çã„ÄÅÂ¢ó„ÇÑ„Åô'},{en:'reduce',ja:'Ê∏õ„Çâ„Åô'},{en:'gather',ja:'ÈõÜ„ÇÅ„Çã'},{en:'explore',ja:'Êé¢Á¥¢„Åô„Çã'},
  {en:'defeat',ja:'Êâì„Å°ÂÄí„Åô'},{en:'guard',ja:'ÂÆà„Çã'},{en:'release',ja:'Ëß£Êîæ„Åô„Çã'},{en:'vanish',ja:'Ê∂à„Åà„Çã'}
];
const FALLBACK_MONSTERS=[
  {id:'ash_wyrm',ja:'„Ç¢„ÉÉ„Ç∑„É•„Éª„ÉØ„Éº„É†'},{id:'dust_lizard',ja:'„ÉÄ„Çπ„Éà„Éª„É™„Ç∂„Éº„Éâ'},{id:'ember_golem',ja:'„Ç®„É≥„Éê„Éº„Éª„Ç¥„Éº„É¨„É†'},{id:'night_siren',ja:'„Éä„Ç§„Éà„Éª„Çµ„Ç§„É¨„É≥'}
];

let words=[], MONSTERS=[], enemy=null, Q=null;

const state={
  total:0,   // Á¥ØË®àEXPÔºà‰øùÂ≠òÔºâ
  lv:1, exp:0, nextExp:EXP0,
  maxHP:30, hp:30, atk:5,

  // „É¢„É≥„Çπ„Çø„ÉºÈ†Ü
  mi:0,
  // ÊïµLvÔºöÂàùÊúü„ÅØÂ∏∏„Å´1
  enemyLv:1,

  used:new Set()
};

function save(){ try{ localStorage.setItem(KEY, String(state.total)); }catch(e){} }

// Á¥ØË®àEXP„Åã„Çâ (lv, exp, nextExp) „ÇíÂæ©ÂÖÉÔºàÂøÖË¶ÅEXP„ÅåÂ¢ó„Åà„ÇãÊñπÂºèÔºâ
function recalcFromTotal(){
  let lv=1, next=EXP0, t=state.total;
  while(t >= next){
    t -= next;
    lv++;
    next = Math.round(next * EXP_GROW);
  }
  state.lv=lv; state.exp=t; state.nextExp=next;

  // „Çπ„ÉÜ„Éº„Çø„ÇπÔºà„Åì„Åì„ÇÇÂ•Ω„Åø„ÅßË™øÊï¥Ôºâ
  state.maxHP = 26 + state.lv*8;
  state.atk   = 5  + Math.floor(state.lv*1.2);
  state.hp = clamp(state.hp,0,state.maxHP);

}

function render(){
  $('lv').textContent=state.lv;
  $('atk').textContent=state.atk;
  $('hpText').textContent=`${state.hp} / ${state.maxHP}`;
  $('expText').textContent=`${state.exp} / ${state.nextExp}`;
  bar('hpBar', state.hp/state.maxHP);
  bar('expBar', state.exp/state.nextExp);
}

function gainExp(x){
  if(x<=0) return;
  const beforeLv=state.lv;

  state.total += x; save();
  recalcFromTotal();

  if(state.lv>beforeLv){
    const heal = Math.round(state.maxHP*0.35);
    state.hp = clamp(state.hp + heal, 0, state.maxHP);
    log(`<span class="ok">‚ú® „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ Lv${beforeLv} ‚Üí Lv${state.lv}Ôºà+${heal}HPÔºâ</span>`);
  }
  render();
}

async function loadMonsters(){
  try{
    const res=await fetch('img/monsters/monsters.js',{cache:'no-store'});
    if(!res.ok) throw 0;
    const t=await res.text();
    const i=t.indexOf('['), j=t.lastIndexOf(']');
    const arr=new Function(`return ${t.slice(i,j+1)}`)();
    if(!Array.isArray(arr) || !arr[0]?.id || !arr[0]?.ja) throw 0;
    MONSTERS=arr;
  }catch(e){ MONSTERS=FALLBACK_MONSTERS; }
}

function setEnemyImage(mon){
  const img=$('enemyImg');
  img.style.display='block';
  img.src=`img/monsters/${mon.id}.png`;
  img.alt=mon.ja;
  img.onerror=()=>img.style.display='none';
}

function updateEnemy(){
  $('enemyHpText').textContent=`${enemy.hp} / ${enemy.maxHP}`;
  bar('enemyHpBar', enemy.hp/enemy.maxHP);
}

// Êïµ„ÅÆÂàùÊúüÂá∫ÁèæLvÔºömax(1, lv-10)
// ÂÄí„Åô„Åî„Å®„Å´ enemyLv++ÔºàÂ∏∏„Å´1„Åö„Å§‰∏äÊòáÔºâ
function spawnEnemy(){
  const mon = MONSTERS[state.mi % MONSTERS.length] || FALLBACK_MONSTERS[0];
  state.mi = (state.mi+1) % MONSTERS.length;

  const L = state.enemyLv;

  enemy={
    id:mon.id, name:mon.ja, level:L,
    maxHP: 18 + L*10,
    hp:    18 + L*10,
    atkMin: 3 + L*2,
    atkMax: 6 + L*3,
    xp: 6 + Math.floor(L*1.2)
  };

  $('enemyName').textContent=`Lv${enemy.level}`;
  setEnemyImage(mon);
  updateEnemy();
  log(`üëæ „É¢„É≥„Çπ„Çø„Éº„ÅåÁèæ„Çå„ÅüÔºÅ`);
}

async function loadWords(){
  try{
    const c=await (await fetch('en_ja/categories.json',{cache:'no-store'})).json();
    const files=Array.isArray(c?.files)?c.files:[];
    if(!files.length) throw 0;
    const all=(await Promise.all(files.map(n=>fetch(`en_ja/${n}.json`,{cache:'no-store'}).then(r=>r.json())))).flat();
    if(!all.length || !('en'in all[0]) || !('ja'in all[0])) throw 0;
    words=all;
  }catch(e){ words=FALLBACK_WORDS; }
}

function shuffle(a){
  for(let i=a.length-1;i>0;i--){ const j=R(i+1); [a[i],a[j]]=[a[j],a[i]]; }
  return a;
}

function nextQuestion(){
  if(state.hp<=0){ $('question').textContent='‚ò†Ô∏è GAME OVER'; $('choices').innerHTML=''; return; }
  if(!words.length){ $('question').textContent='ÂçòË™û„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'; $('choices').innerHTML=''; return; }

  const idxs=words.map((_,i)=>i).filter(i=>!state.used.has(i));
  if(!idxs.length){ state.used.clear(); return nextQuestion(); }

  const pick=idxs[R(idxs.length)];
  state.used.add(pick);
  const q=words[pick];

  const correct=q.en;
  const set=new Set([correct]);
  while(set.size<4 && set.size<words.length) set.add(words[R(words.length)].en);

  Q={ja:q.ja, ans:correct, ch:shuffle([...set])};

  $('question').textContent=`„Äå${Q.ja}„Äç„ÅÆËã±Ë™û„ÅØÔºü`;
  const box=$('choices'); box.innerHTML='';
  Q.ch.forEach(w=>{
    const b=document.createElement('button');
    b.className='choice';
    b.textContent=w;
    b.onclick=()=>answer(w);
    box.appendChild(b);
  });
}

function playerDmg(){
  const base=state.atk;
  return base + R(1+Math.max(1,Math.floor(base*0.6)));
}
function recoilDmg(){
  const L=enemy.level;
  return (2+Math.floor(L*0.8)) + R(2+Math.floor(L*0.4));
}
function fatalWrongDmg(){
  const p = Math.round(state.maxHP*(0.55 + Math.min(0.20, enemy.level*0.01)));
  const e = enemy.atkMax*2;
  return Math.max(p,e) + R(1+Math.round(state.maxHP*0.10));
}

function disableChoices(){
  document.querySelectorAll('button.choice').forEach(b=>b.disabled=true);
}

function answer(choice){
  if(!Q || !enemy || state.hp<=0) return;
  disableChoices();
  clearLog();

  const btns = Array.from(document.querySelectorAll('button.choice'));
  const correctBtn = btns.find(b=>b.textContent===Q.ans);
  if(correctBtn) correctBtn.classList.add('correct');

  if(choice===Q.ans){
    const d=playerDmg();
    enemy.hp=clamp(enemy.hp-d,0,enemy.maxHP);
    log(`‚úÖ Ê≠£Ëß£ÔºÅ <span class="ok">${d} „ÉÄ„É°„Éº„Ç∏</span>`);
    updateEnemy();

    const self=recoilDmg();
    state.hp=clamp(state.hp-self,0,state.maxHP);
    log(`üí• ÂèçÂãïÔºÅ <span class="bad">${self} „ÉÄ„É°„Éº„Ç∏</span>`);
  }else{
    const d=fatalWrongDmg();
    state.hp=clamp(state.hp-d,0,state.maxHP);
    log(`‚ùå ‰∏çÊ≠£Ëß£‚Ä¶ <span class="bad">${d} „ÉÄ„É°„Éº„Ç∏</span>`);
    const wrongBtn = btns.find(b=>b.textContent===choice);
    if(wrongBtn) wrongBtn.classList.add('wrong');
  }

  render();

  if(state.hp<=0){
    log(`<span class="bad">‚ò†Ô∏è ÂÄí„Çå„Åü‚Ä¶</span>`);
    nextQuestion();
    return;
  }

  if(enemy.hp<=0){
    const heal=Math.round(state.maxHP*0.18)+2;
    state.hp=clamp(state.hp+heal,0,state.maxHP);
    log(`üèÜ ÊíÉÁ†¥ÔºÅ <span class="ok">+${enemy.xp} EXP</span> / <span class="ok">+${heal}HP</span>`);

    // ÊïµLv„Çí‰∏ä„Åí„ÇãÔºàÊúÄÂ§ß„Åß„Éó„É¨„Ç§„É§„ÉºLv„Åæ„ÅßÔºâ
    state.enemyLv = state.enemyLv + 1;

    render();
    gainExp(enemy.xp);
  }

  setTimeout(()=>{
    if(state.hp<=0) return;
    if(enemy.hp<=0) spawnEnemy();
    nextQuestion();
  }, 1000);
}

function init(){
  state.total = Number(localStorage.getItem(KEY) || '0');
  if(!Number.isFinite(state.total) || state.total<0) state.total=0;

  recalcFromTotal();
  state.enemyLv = 1;
  state.hp = state.maxHP; // HP„ÅØÈñãÂßãÊôÇÂÖ®Âø´Ôºà‰øùÂ≠ò„Åó„Å™„ÅÑÔºâ
  render();

  loadMonsters().then(()=>{
    const idx = MONSTERS.findIndex(m=>m?.id==='dust_lizard');
    state.mi = idx>=0 ? idx : 0;

    loadWords().then(()=>{
      spawnEnemy();
      nextQuestion();
    });
  });
}

init();
</script>
</body>
</html>
