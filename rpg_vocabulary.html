<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç‹©ã‚Š è‹±å˜èª</title>
<style>
  :root{--bg:#020617;--ok:#22c55e;--bad:#ef4444}
  *{box-sizing:border-box}
  html,body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;
  background-color:#0b1a33;
  background-image:url('img/bg_rpg_field.png');
  background-repeat:no-repeat;
  background-position:center top;
  background-size:cover;
  color:#ffffff;
}

  #wrap{min-height:100vh;display:grid;grid-template-rows:auto minmax(0,1fr) auto;gap:8px;padding:8px}
  #topGrid{display:grid;grid-template-columns:minmax(0,1.1fr) minmax(0,1fr);grid-template-rows:auto minmax(0,1fr);gap:8px;align-items:start}
  .panel{background:none;border-radius:0;padding:0}
  .compact{font-size:14px;line-height:1.3}
  .row{display:flex;align-items:center;gap:6px;margin-bottom:4px}
  .row span.label{opacity:.8}
  .bar{flex:1;height:12px;border-radius:999px;overflow:hidden;background:#020617}
  .bar>span{display:block;height:100%;width:0;transition:width .25s}
  .hp>span{background:linear-gradient(90deg,#ef4444,#b91c1c)}
  .exp>span{background:linear-gradient(90deg,#38bdf8,#0ea5e9)}
  .val{min-width:90px;text-align:right;opacity:.9;font-size:12px}

  #question{margin:0 0 6px;font-size:16px}
  #choices{ display:flex; flex-direction:column; gap:6px; }
  button.choice{padding:8px;border-radius:8px;border:0;background:#111827;color:inherit;font-size:14px;cursor:pointer}
  button.choice:disabled{opacity:.6;cursor:default}

  #logWrap{min-height:96px;max-height:30vh;display:flex;flex-direction:column;padding-top:2px;background:rgba(0,0,0,.35);border-radius:8px}
  #log{flex:1;overflow:auto;font-size:13px;padding:4px 6px}
  #log p{margin:2px 0}
  .ok{color:var(--ok)}
  .bad{color:var(--bad)}
  .blink{animation:blink .24s 3}
  @keyframes blink{50%{filter:brightness(2)}}

  #buttonsInline{margin-top:6px;text-align:left}
  #buttonsInline button{margin-right:4px;padding:4px 10px;font-size:12px;border-radius:6px;border:0;cursor:pointer;background:#111827;color:inherit}

  #enemyView img{display:block;width:100%;height:auto;max-height:30vh;object-fit:contain}
</style>
</head>
<body>
<div id="wrap">
  <div id="topGrid">
    <section id="heroBox" class="panel compact">
      <div class="row"><span class="label">Lv</span><span id="lv">1</span></div>
      <div class="row"><span class="label">EXP</span><div class="bar exp"><span id="expBar"></span></div><span class="val" id="expText">0 / 20</span></div>
      <div class="row"><span class="label">HP</span><div class="bar hp"><span id="hpBar"></span></div><span class="val" id="hpText">30 / 30</span></div>
      <div class="row"><span class="label">ATK</span><span id="atk">5</span></div>
    </section>

    <section id="enemyBox" class="panel compact">
      <div class="row"><span class="label">ENEMY</span><span id="enemyName">ãƒ€ã‚¹ãƒˆãƒªã‚¶ãƒ¼ãƒ‰ Lv1</span></div>
      <div class="row"><span class="label">HP</span><div class="bar hp"><span id="enemyHpBar"></span></div><span class="val" id="enemyHpText">0 / 0</span></div>
    </section>

    <section id="qaBox" class="panel">
      <p id="question">â€”</p>
      <div id="choices"></div>
      <div id="buttonsInline">
        <button id="nextBtn" style="display:none">æ¬¡ã®æ•µ â–¶</button>
      </div>
    </section>

    <section id="enemyView" class="panel">
      <img id="enemyImg" src="" alt="" style="display:block;width:100%;height:auto;object-fit:contain;opacity:0.95" onerror="this.style.display='none'" />
    </section>
  </div>

  <section id="logWrap" class="panel">
    <div id="log"></div>
  </section>
</div>

<script>
const KEY = 'midunohi.exam.exp';
const rand = n => Math.floor(Math.random()*n);
const clamp = (x,a,b) => Math.max(a,Math.min(b,x));
const setBar = (id,r) => { const el=document.getElementById(id); if(el) el.style.width=(100*clamp(r,0,1)).toFixed(1)+'%'; };
const log = html => { const el=document.getElementById('log'); if(!el) return; el.insertAdjacentHTML('beforeend',`<p>${html}</p>`); el.scrollTop=el.scrollHeight; };

// en_ja/words.json ãŒèª­ã¿è¾¼ã‚ãªã„ç’°å¢ƒç”¨ã®æœ€å°é™ã®ä»£æ›¿ãƒ‡ãƒ¼ã‚¿
const FALLBACK_WORDS=[
  {en:'increase', ja:'å¢—ãˆã‚‹ã€å¢—ã‚„ã™'},
  {en:'reduce',   ja:'æ¸›ã‚‰ã™'},
  {en:'gather',   ja:'é›†ã‚ã‚‹'},
  {en:'explore',  ja:'æ¢ç´¢ã™ã‚‹'},
  {en:'defeat',   ja:'æ‰“ã¡å€’ã™ã€æ‰“ã¡è² ã‹ã™'},
  {en:'guard',    ja:'å®ˆã‚‹'},
  {en:'release',  ja:'è§£æ”¾ã™ã‚‹'},
  {en:'vanish',   ja:'æ¶ˆãˆã‚‹'},
];

// monsters.js ãŒèª­ã‚ãªã„ç’°å¢ƒç”¨ã®ä»£æ›¿ãƒ‡ãƒ¼ã‚¿
const FALLBACK_MONSTERS = [
  { id: 'ash_wyrm',    ja: 'ã‚¢ãƒƒã‚·ãƒ¥ãƒ»ãƒ¯ãƒ¼ãƒ ' },
  { id: 'dust_lizard', ja: 'ãƒ€ã‚¹ãƒˆãƒ»ãƒªã‚¶ãƒ¼ãƒ‰' },
  { id: 'ember_golem', ja: 'ã‚¨ãƒ³ãƒãƒ¼ãƒ»ã‚´ãƒ¼ãƒ¬ãƒ ' },
  { id: 'night_siren', ja: 'ãƒŠã‚¤ãƒˆãƒ»ã‚µã‚¤ãƒ¬ãƒ³' },
];

let wordsData = [];
let MONSTERS = [];

const state={
  lv:1, exp:0, nextExp:20,
  hp:30, maxHP:30, baseATK:5,

  // æ•µã®é€²è¡Œï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å‘¨å›Lv / ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é †ï¼‰
  enemyLevel:1,
  monsterIndex:0,

  pool:[],
  used:new Set(),
  totalExp:0
};

// ä¿å­˜ã•ã‚ŒãŸçµŒé¨“å€¤ã‚’å¾©å…ƒã—ã¦ãƒ¬ãƒ™ãƒ«è¨ˆç®—
function loadSavedExp(){
  const v = Number(localStorage.getItem(KEY) || '0');
  if(!Number.isFinite(v) || v <= 0){
    resetStats();
    return;
  }
  state.totalExp = v;
  resetStats();
  let rest = v;
  while(rest >= state.nextExp){
    rest -= state.nextExp;
    silentLevelUp();
  }
  state.exp = rest;
}

function resetStats(){
  state.lv=1;
  state.exp=0;
  state.nextExp=20;
  state.baseATK=5;
  state.maxHP=30;
  state.hp=state.maxHP;

  state.enemyLevel=1;
  state.monsterIndex=0;
}

function silentLevelUp(){
  state.lv++;
  const hpGain=8+Math.floor(state.lv*1.5);
  state.maxHP+=hpGain;
  state.hp=state.maxHP;
  state.baseATK+=2;
  state.nextExp=Math.round(state.nextExp*1.35);
}

function levelUp(){
  silentLevelUp();
  log(`<span class="ok">âœ¨ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv${state.lv}</span>`);
}

function addExp(x){
  if(x<=0) return;
  state.totalExp += x;
  try{ localStorage.setItem(KEY, String(state.totalExp)); }catch(e){}
  state.exp += x;
  while(state.exp >= state.nextExp){
    state.exp -= state.nextExp;
    levelUp();
  }
  renderHUD();
}

// ----------------
// ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼èª­ã¿è¾¼ã¿ï¼ˆimg/monsters/monsters.jsï¼‰
// ----------------
async function loadMonsters(){
  try{
    const res = await fetch('img/monsters/monsters.js', { cache:'no-store' });
    if(!res.ok) throw new Error('monsters.js http error');
    const txt = await res.text();

    // export const MONSTERS = [ ... ]; ã‹ã‚‰ [ ... ] éƒ¨åˆ†ã ã‘æŠœãå‡ºã—ã¦è©•ä¾¡
    const i = txt.indexOf('[');
    const j = txt.lastIndexOf(']');
    if(i < 0 || j < 0 || j <= i) throw new Error('monsters.js parse error');
    const arrText = txt.slice(i, j+1);
    const arr = new Function(`return ${arrText}`)();

    if(!Array.isArray(arr) || !arr.length || !arr[0].id || !arr[0].ja) throw new Error('monsters.js bad format');
    MONSTERS = arr;
    log(`ğŸ§© monsters.js ã‹ã‚‰ ${MONSTERS.length} ä½“èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚`);
  }catch(e){
    MONSTERS = FALLBACK_MONSTERS;
    log('<span class="bad">âš  monsters.js ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸãŸã‚ã€å†…è”µã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ä¸€è¦§ã§é€²è¡Œã—ã¾ã™ã€‚</span>');
  }
}

function setEnemyImage(mon){
  const img = document.getElementById('enemyImg');
  if(!img) return;
  img.style.display = 'block';
  img.src = `img/monsters/${mon.id}.png`;
  img.alt = mon.ja;
  img.onerror = () => { img.style.display = 'none'; };
}

// ----------------
// æ•µé–¢é€£ï¼ˆé †ç•ªã«ç™»å ´ / å‘¨å›ã§Lv+1ï¼‰
// ----------------
let enemy=null;
function currentMonster(){
  if(!MONSTERS.length) return { id:'dust_lizard', ja:'ãƒ€ã‚¹ãƒˆãƒ»ãƒªã‚¶ãƒ¼ãƒ‰' };
  return MONSTERS[clamp(state.monsterIndex,0,MONSTERS.length-1)];
}

function spawnEnemy(){
  const mon = currentMonster();
  const L = state.enemyLevel;
  enemy={
    id: mon.id,
    name: mon.ja,
    level: L,
    maxHP: 28 + L*8,
    hp:    28 + L*8,
    atkMin: 3 + L*2,
    atkMax: 6 + L*2,
    xp:    10 + L*5
  };
  document.getElementById('enemyName').textContent = `${enemy.name} Lv${enemy.level}`;
  setEnemyImage(mon);
  updateEnemyHUD();
  log(`ğŸ‘¾ Lv${enemy.level} ${enemy.name} ãŒç¾ã‚ŒãŸï¼`);
}

function advanceMonster(){
  if(!MONSTERS.length) return;

  state.monsterIndex++;
  if(state.monsterIndex >= MONSTERS.length){
    state.monsterIndex = 0;
    state.enemyLevel++;
    log(`<span class="ok">ğŸ” å‘¨å›ï¼ æ•µLvãŒ ${state.enemyLevel} ã«ãªã£ãŸ</span>`);
  }
}

function renderHUD(){
  document.getElementById('lv').textContent=state.lv;
  document.getElementById('atk').textContent=state.baseATK;
  document.getElementById('hpText').textContent=`${state.hp} / ${state.maxHP}`;
  document.getElementById('expText').textContent=`${state.exp} / ${state.nextExp}`;
  setBar('hpBar', state.hp/state.maxHP);
  setBar('expBar', state.exp/state.nextExp);
}

function updateEnemyHUD(){
  document.getElementById('enemyHpText').textContent=`${enemy.hp} / ${enemy.maxHP}`;
  setBar('enemyHpBar', enemy.hp/enemy.maxHP);
}

// å˜èªãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼ˆcategories.json -> files é…åˆ—ã‚’å…¨éƒ¨èª­ã‚€ï¼‰
async function loadWords(){
  try{
    const catRes = await fetch('en_ja/categories.json', { cache: 'no-store' });
    if(!catRes.ok) throw new Error('categories http error');

    const cat = await catRes.json();
    const files = Array.isArray(cat?.files) ? cat.files : [];
    if(files.length === 0) throw new Error('categories empty files');

    const results = await Promise.all(
      files.map(async (name) => {
        const res = await fetch(`en_ja/${name}.json`, { cache: 'no-store' });
        if(!res.ok) throw new Error(`${name}.json http error`);
        const data = await res.json();
        if(!Array.isArray(data)) throw new Error(`${name}.json bad format (not array)`);
        return data;
      })
    );

    const merged = results.flat();
    if(!merged.length || !('en' in merged[0]) || !('ja' in merged[0])) {
      throw new Error('merged bad format');
    }

    wordsData = merged;
    log(`ğŸ“– categories.json ã‹ã‚‰ ${files.length} ãƒ•ã‚¡ã‚¤ãƒ«ã€åˆè¨ˆ ${wordsData.length} ä»¶èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚`);
  }catch(e){
    wordsData = FALLBACK_WORDS;
    log('<span class="bad">âš  categories.json / å˜èªãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸãŸã‚ã€å†…è”µã®ã‚µãƒ³ãƒ—ãƒ«å˜èªã§å‡ºé¡Œã—ã¾ã™ã€‚</span>');
  }

  state.pool = wordsData;
}

// å‡ºé¡Œã¾ã‚ã‚Š
let currentQ=null;
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=rand(i+1);
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function nextQuestion(){
  if(!state.pool || !state.pool.length){
    document.getElementById('question').textContent='å˜èªãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚';
    document.getElementById('choices').innerHTML='';
    return;
  }

  const poolIdx = state.pool.map((_,i)=>i).filter(i=>!state.used.has(i));
  if(!poolIdx.length){
    state.used.clear();
    return nextQuestion();
  }

  const pick = poolIdx[rand(poolIdx.length)];
  state.used.add(pick);
  const q = state.pool[pick];

  const correct = q.en;
  const choicesSet = new Set([correct]);
  while(choicesSet.size < 4 && choicesSet.size < state.pool.length){
    const cand = state.pool[rand(state.pool.length)].en;
    choicesSet.add(cand);
  }
  const choices = shuffle([...choicesSet]);

  currentQ = { ja:q.ja, ans:correct, choices };
  document.getElementById('question').textContent = `ã€Œ${currentQ.ja}ã€ã®è‹±èªã¯ï¼Ÿ`;
  const box = document.getElementById('choices');
  box.innerHTML='';
  currentQ.choices.forEach(w=>{
    const b=document.createElement('button');
    b.className='choice';
    b.textContent=w;
    b.onclick=()=>answer(w);
    box.appendChild(b);
  });
}

function playerAttack(){
  const base=state.baseATK;
  const v=Math.max(1,Math.floor(base*0.5));
  return base+rand(v+1);
}

function enemyAttack(){
  return enemy.atkMin+rand(enemy.atkMax-enemy.atkMin+1);
}

function answer(choice){
  if(!currentQ) return;
  [...document.querySelectorAll('button.choice')].forEach(b=>b.disabled=true);

  if(choice===currentQ.ans){
    const dmg = playerAttack();
    enemy.hp = clamp(enemy.hp - dmg, 0, enemy.maxHP);
    log(`âœ… æ­£è§£ï¼ <span class="ok">${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
    updateEnemyHUD();

    // âœ… æ­£è§£æ™‚ã®åå‹•ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆæ•µLvã«å¿œã˜ã¦å¢—ãˆã‚‹ï¼‰
    const selfDmg = 1 + rand(enemy.level + 1); // 1..(Lv+1)
    state.hp = clamp(state.hp - selfDmg, 0, state.maxHP);
    log(`ğŸ’¥ åå‹•ï¼ <span class="bad">${selfDmg} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
  }else{
    const dmg = enemyAttack();
    state.hp = clamp(state.hp - dmg, 0, state.maxHP);
    log(`âŒ ä¸æ­£è§£â€¦ <span class="bad">${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
  }

  renderHUD();
  checkEnd();
  if(!isBattleOver()) setTimeout(nextQuestion,300);
}

function isBattleOver(){
  return state.hp<=0 || enemy.hp<=0;
}

function checkEnd(){
  const nextBtn=document.getElementById('nextBtn');
  if(enemy.hp<=0){
    log(`ğŸ† æ’ƒç ´ï¼ +${enemy.xp} EXP`);
    addExp(enemy.xp);

    // æ¬¡ã®æ•µã¯ã€Œé †ç•ªã«é€²ã‚ã‚‹ã€ã€‚å‘¨å›ã—ã¦æœ€åˆã«æˆ»ã‚‹ç¬é–“ã«æ•µLv+1ã€‚
    advanceMonster();

    nextBtn.style.display='inline-block';
  }
}

function nextEnemy(){
  spawnEnemy();
  nextQuestion();
  document.getElementById('nextBtn').style.display='none';
}

async function init(){
  loadSavedExp();
  renderHUD();

  await loadMonsters();

  // é–‹å§‹ä½ç½®ã¯ dust_lizardï¼ˆå­˜åœ¨ã™ã‚Œã°ãã“ã‹ã‚‰ï¼‰
  const startId = 'dust_lizard';
  const idx = MONSTERS.findIndex(m => m && m.id === startId);
  state.monsterIndex = idx >= 0 ? idx : 0;

  await loadWords();

  spawnEnemy();
  nextQuestion();
  document.getElementById('nextBtn').onclick=nextEnemy;
}

init();
</script>
</body>
</html>
