<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>è‹±å˜èªRPGãƒãƒˆãƒ«</title>
<style>
  :root{--bg:#0b1020;--accent:#2dd4bf;--danger:#ef4444;--ok:#22c55e;--muted:#94a3b8}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;background:var(--bg);color:#e5e7eb;overflow:hidden}

  #sceneWrap{position:relative;width:100vw;height:100vh;overflow:hidden}
  #battleSvg{position:absolute;inset:0;width:100%;height:100%;display:block}

  #overlay{position:absolute;inset:0;display:flex;flex-direction:column;gap:10px;padding:10px;z-index:10;pointer-events:none}
  .compact{font-size:14px;line-height:1.2;text-shadow:0 1px 2px #000}
  .line{display:flex;align-items:center;gap:8px}
  .label{opacity:.9;margin-right:4px}
  .bar{height:14px;background:rgba(0,0,0,.35);border-radius:9px;overflow:hidden;flex:1;min-width:220px;}
  .bar>span{display:block;height:100%;width:0;transition:width .35s}
  .hp>span{background:linear-gradient(90deg,#ef4444,#b91c1c)}
  .exp>span{background:linear-gradient(90deg,#38bdf8,#0ea5e9)}
  .val{opacity:.9;margin-left:6px}

  #statusRow{display:flex;justify-content:space-between;align-items:flex-start}
  #heroStatus,#enemyStatus{display:flex;flex-direction:column;gap:6px;pointer-events:auto}

  #qa{display:flex;flex-direction:column;align-items:center;gap:10px;margin:0 auto;max-width:min(920px,92vw);pointer-events:auto}
  #question{font-size:18px;margin:0;text-align:center;text-shadow:0 1px 2px #000}
  #choices{display:grid;grid-template-columns:1fr 1fr;gap:10px;width:100%}
  button.choice{background:rgba(27,41,71,.85);color:#e5e7eb;border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:12px;font-size:16px;cursor:pointer;transition:.15s}
  button.choice:hover{transform:translateY(-1px);box-shadow:0 6px 16px #0006}

  #logWrap{margin:0 auto;max-width:min(920px,92vw);width:100%;pointer-events:auto}
  #log{height:22vh;overflow:auto;font-size:14px;background:transparent}
  #log p{margin:.35em 0;text-shadow:0 1px 2px #000}
  .ok{color:var(--ok)} .bad{color:var(--danger)} .blink{animation:blink .24s 3}
  @keyframes blink{50%{filter:brightness(2)}}
  #enemyG.hit #enemyBody{animation:flash .24s 3}
  @keyframes flash{50%{filter:brightness(2)}}
</style>
</head>
<body>
  <section id="sceneWrap">
    <div id="overlay">
      <div id="statusRow" class="compact">
        <div id="heroStatus">
          <div class="line"><span class="label">Lv</span><span id="lv">1</span><span class="label" style="margin-left:auto">Stage</span><span id="stage">1-1</span></div>
          <div class="line"><span class="label">EXP</span><div class="bar exp"><span id="expBar"></span></div><span class="val" id="expText">0 / 20</span></div>
          <div class="line"><span class="label">HP</span><div class="bar hp"><span id="hpBar"></span></div><span class="val" id="hpText">30 / 30</span></div>
          <div class="line"><span class="label">ATK</span><span id="atk">5</span></div>
        </div>
        <div id="enemyStatus">
          <div class="line"><span class="label">ENEMY</span><span id="enemyName">æ•µ</span></div>
          <div class="line"><span class="label">HP</span><div class="bar hp"><span id="enemyHpBar"></span></div><span class="val" id="enemyHpText">0 / 0</span></div>
        </div>
      </div>

      <div id="qa">
        <div id="question">â€”</div>
        <div id="choices"></div>
      </div>

      <div id="logWrap">
        <div id="log"></div>
        <div style="text-align:right">
          <button id="nextBtn" style="display:none">æ¬¡ã®æ•µã¸ â–¶</button>
          <button id="retryBtn" style="display:none">ãƒªãƒˆãƒ©ã‚¤ âŸ³</button>
        </div>
      </div>
    </div>

    <svg id="battleSvg" viewBox="0 0 960 540" preserveAspectRatio="xMidYMid slice">
      <defs>
        <linearGradient id="sky" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#1b2d5a"/>
          <stop offset="100%" stop-color="#0b152b"/>
        </linearGradient>
        <linearGradient id="groundGrad" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#0e213e"/>
          <stop offset="100%" stop-color="#091528"/>
        </linearGradient>
        <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.5"/>
        </filter>
      </defs>
      <rect x="0" y="0" width="960" height="540" fill="url(#sky)"/>
      <g opacity="0.35">
        <path d="M0,330 L120,260 260,305 380,250 520,300 680,240 820,290 960,260 960,540 0,540 Z" fill="#274068"/>
      </g>
      <rect x="0" y="340" width="960" height="200" fill="url(#groundGrad)"/>

      <g id="playerG" transform="translate(180,360)" filter="url(#shadow)" opacity="0.9">
        <circle cx="0" cy="-70" r="26" fill="#20324f"/>
        <rect x="-24" y="-50" width="48" height="90" rx="10" fill="#1a2a46"/>
        <g transform="translate(40,-12) rotate(-18)">
          <rect x="0" y="0" width="80" height="12" rx="2" fill="#ced7e6"/>
          <rect x="-10" y="-5" width="14" height="22" rx="2" fill="#8a5a2b"/>
        </g>
        <ellipse cx="0" cy="56" rx="56" ry="14" fill="#000" opacity="0.35"/>
      </g>

      <g id="enemyG" transform="translate(760,370)" filter="url(#shadow)">
        <path id="enemyBody" d="M-90,0 C-90,-72 90,-72 90,0 C90,44 -90,44 -90,0 Z" fill="#3d8f7c" stroke="#295e52" stroke-width="5"/>
        <path d="M-52,-24 C-26,-50 26,-50 52,-24" fill="none" stroke="#7fd8c4" stroke-width="8" stroke-linecap="round" opacity="0.45"/>
        <ellipse cx="-30" cy="-10" rx="12" ry="9" fill="#13252a"/>
        <ellipse cx="30" cy="-10" rx="12" ry="9" fill="#13252a"/>
        <ellipse cx="0" cy="40" rx="96" ry="16" fill="#000" opacity="0.28"/>
      </g>
    </svg>
  </section>

<script>
// ====== åˆæœŸåŒ–ã®å‰ã«: ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
const rand = (n)=>Math.floor(Math.random()*n);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function setBar(id,ratio){ const el=document.getElementById(id); if(!el) return; el.style.width=(100*clamp(ratio,0,1)).toFixed(1)+'%'; }
function log(html){ const el=document.getElementById('log'); if(!el) return; el.insertAdjacentHTML('beforeend',`<p>${html}</p>`); el.scrollTop=el.scrollHeight; }

// ====== ãƒ‡ãƒ¼ã‚¿ï¼ˆé›£ã—ã‚ã®èªå½™ï¼‰ ======
const WORDS=[
  {jp:'å¿è€',ans:'perseverance',opts:['bravery','tenacity','perseverance','humility']},
  {jp:'è¦‹ã›ã‹ã‘',ans:'pretense',opts:['presence','pretense','premise','protÃ©gÃ©']},
  {jp:'å½“æƒ‘',ans:'consternation',opts:['contemplation','constellation','consternation','conflagration']},
  {jp:'ä¸å‰ãª',ans:'ominous',opts:['ominous','amiable','anxious','arduous']},
  {jp:'å®Ÿç”¨çš„ãª',ans:'pragmatic',opts:['dogmatic','pragmatic','problematic','charismatic']},
  {jp:'ç„¡æ„å‘³ã•',ans:'futility',opts:['fertility','frivolity','futility','fluidity']},
  {jp:'å¹³é™',ans:'equanimity',opts:['equity','equanimity','equivalence','equation']},
  {jp:'ç”˜ç¾ãª',ans:'luscious',opts:['lucid','ludicrous','luscious','lush']},
  {jp:'å³æ ¼ãª',ans:'stringent',opts:['strident','stringent','stringy','striking']},
  {jp:'æ‡ç–‘çš„ãª',ans:'skeptical',opts:['spectral','skeptical','skeletal','spherical']}
];

const ENEMIES=[
  {name:'ã‚¹ãƒ©ã‚¤ãƒ ', hp:28, atk:[3,6], xp:12},
  {name:'ã‚¦ãƒ«ãƒ•', hp:40, atk:[5,9], xp:18},
  {name:'ã‚ªãƒ¼ã‚¬', hp:65, atk:[8,14], xp:28}
];

// ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
const state={
  stageWorld:1, stageLocal:1,
  lv:1, exp:0, nextExp:20,
  baseATK:5,
  hp:30, maxHP:30,
  enemy:null,
  pool:[], used:new Set(),
};

// ====== ä¸»è¦å‡¦ç† ======
function init(){
  // DOMå­˜åœ¨ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å°ï¼‰
  ['expBar','hpBar','enemyHpBar','question','choices'].forEach(id=>{ if(!document.getElementById(id)) console.warn('#'+id+' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); });
  // ãƒ—ãƒ¼ãƒ«
  state.pool=[...WORDS]; state.used.clear();
  spawnEnemy();
  renderHUD();
  smokeTests();
}

function spawnEnemy(){
  const base=ENEMIES[Math.min(ENEMIES.length-1, Math.floor((state.stageLocal-1)/2))];
  const scale=1+(state.stageWorld-1)*0.25+(state.stageLocal-1)*0.1;
  state.enemy={
    name: base.name+(scale>1.2?'ï¼ˆå¼·åŒ–ï¼‰':''),
    maxHP: Math.round(base.hp*scale),
    hp: Math.round(base.hp*scale),
    atkMin: Math.round(base.atk[0]*scale),
    atkMax: Math.round(base.atk[1]*scale)
  };
  document.getElementById('enemyName').textContent=state.enemy.name;
  updateEnemyHUD();
  document.getElementById('stage').textContent=`${state.stageWorld}-${state.stageLocal}`;
  nextQuestion();
  log(`<span class="muted">ğŸ‘¾ ${state.enemy.name} ãŒç¾ã‚ŒãŸï¼ï¼ˆHP ${state.enemy.hp}ï¼‰</span>`);
}

function renderHUD(){
  document.getElementById('lv').textContent=state.lv;
  document.getElementById('atk').textContent=state.baseATK;
  document.getElementById('hpText').textContent=`${state.hp} / ${state.maxHP}`;
  document.getElementById('expText').textContent=`${state.exp} / ${state.nextExp}`;
  setBar('hpBar', state.hp/state.maxHP);
  setBar('expBar', state.exp/state.nextExp);
}
function updateEnemyHUD(){
  document.getElementById('enemyHpText').textContent=`${state.enemy.hp} / ${state.enemy.maxHP}`;
  setBar('enemyHpBar', state.enemy.hp/state.enemy.maxHP);
}

// ====== ã‚¯ã‚¤ã‚º ======
let currentQ=null;
function nextQuestion(){
  const poolIdx=state.pool.map((_,i)=>i).filter(i=>!state.used.has(i));
  if(poolIdx.length===0){ state.used.clear(); return nextQuestion(); }
  const pick=poolIdx[rand(poolIdx.length)]; state.used.add(pick);
  const q=state.pool[pick];
  const opts=[...new Set(q.opts)];
  if(!opts.includes(q.ans)) opts[rand(opts.length)]=q.ans;
  currentQ={jp:q.jp, ans:q.ans, choices:shuffle(opts)};
  document.getElementById('question').textContent=`ã€å•é¡Œã€‘ã€Œ${currentQ.jp}ã€ã®è‹±èªã¯ã©ã‚Œï¼Ÿ`;
  const box=document.getElementById('choices'); box.innerHTML='';
  currentQ.choices.forEach(w=>{
    const b=document.createElement('button');
    b.className='choice'; b.textContent=w;
    b.onclick=()=>answer(w);
    box.appendChild(b);
  });
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=rand(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// ====== æˆ¦é—˜åˆ¤å®š ======
function playerAttack(){ const base=state.baseATK; const varr=Math.max(1,Math.floor(base*0.5)); return {dmg: base+rand(varr+1)}; }
function enemyAttack(){ const e=state.enemy; return {dmg: e.atkMin+rand(e.atkMax-e.atkMin+1)}; }

function answer(choice){
  const correct=(choice===currentQ.ans);
  [...document.querySelectorAll('button.choice')].forEach(b=>b.disabled=true);
  if(correct){
    const r=playerAttack();
    state.enemy.hp=clamp(state.enemy.hp-r.dmg,0,state.enemy.maxHP);
    document.getElementById('enemyG').classList.add('hit');
    setTimeout(()=>document.getElementById('enemyG').classList.remove('hit'),260);
    log(`âœ… æ­£è§£ï¼ <span class="ok">${r.dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
    updateEnemyHUD();
  }else{
    const r=enemyAttack();
    state.hp=clamp(state.hp-r.dmg,0,state.maxHP);
    document.getElementById('hpBar').classList.add('blink');
    setTimeout(()=>document.getElementById('hpBar').classList.remove('blink'),260);
    log(`âŒ ä¸æ­£è§£â€¦ <span class="bad">${r.dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
  }
  renderHUD();
  checkEnd();
  if(!isBattleOver()) setTimeout(nextQuestion,350);
}

function isBattleOver(){ return state.hp<=0 || state.enemy.hp<=0; }
function checkEnd(){
  if(state.enemy.hp<=0){
    const xp=Math.ceil(10+state.stageWorld*3+state.stageLocal*2);
    log(`ğŸ† <span class="ok">æ’ƒç ´ï¼</span> +${xp} EXP`);
    addExp(xp);
    document.getElementById('nextBtn').style.display='inline-block';
    document.getElementById('retryBtn').style.display='none';
  }else if(state.hp<=0){
    log('<span class="bad">å€’ã‚Œã¦ã—ã¾ã£ãŸâ€¦</span>');
    document.getElementById('nextBtn').style.display='none';
    document.getElementById('retryBtn').style.display='inline-block';
  }
}

function addExp(x){ state.exp+=x; while(state.exp>=state.nextExp){ state.exp-=state.nextExp; levelUp(); } renderHUD(); }
function levelUp(){ state.lv++; const hpGain=8+Math.floor(state.lv*1.5); const atkGain=2; state.maxHP+=hpGain; state.hp=state.maxHP; state.baseATK+=atkGain; state.nextExp=Math.round(state.nextExp*1.35); log(`âœ¨ <span class=\"ok\">ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼</span> Lv${state.lv} / HP+${hpGain} / ATK+${atkGain}`); }
function nextStage(){ state.stageLocal++; if(state.stageLocal>5){ state.stageLocal=1; state.stageWorld++; } spawnEnemy(); document.getElementById('nextBtn').style.display='none'; }

document.getElementById('nextBtn').onclick=nextStage;
document.getElementById('retryBtn').onclick=()=>{ state.hp=state.maxHP; renderHUD(); spawnEnemy(); document.getElementById('retryBtn').style.display='none'; };

// ====== ã‚¹ãƒ¢ãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ ======
function smokeTests(){
  try{
    const ids=['expBar','hpBar','enemyHpBar','question','choices'];
    ids.forEach(id=>console.assert(document.getElementById(id), `#${id} ãŒã‚ã‚Šã¾ã›ã‚“`));
    setTimeout(()=>{
      const c=document.getElementById('choices');
      console.assert(c.children.length===4, `é¸æŠè‚¢ãŒ4ã¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“: ${c.children.length}`);
      console.log('[SmokeTests] OK');
    },0);
  }catch(e){ console.warn('[SmokeTests] å¤±æ•—:', e); }
}

// ====== èµ·å‹• ======
init();
</script>
</body>
</html>