<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç‹©ã‚Š è‹±å˜èª</title>
<style>
  :root{--bg:#020617;--ok:#22c55e;--bad:#ef4444}
  *{box-sizing:border-box}
  html,body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;
    background:#0b1a33 url('img/bg_rpg_field.png') no-repeat center top/cover;
    color:#fff;
  }

  #wrap{min-height:100vh;display:grid;grid-template-rows:auto minmax(0,1fr) auto;gap:8px;padding:8px}
  #topGrid{display:grid;grid-template-columns:minmax(0,1.1fr) minmax(0,1fr);grid-template-rows:auto minmax(0,1fr);gap:8px;align-items:start}
  .panel{background:none;border-radius:0;padding:0}
  .compact{font-size:14px;line-height:1.3}
  .row{display:flex;align-items:center;gap:6px;margin-bottom:4px}
  .row .label{opacity:.8}
  .bar{flex:1;height:12px;border-radius:999px;overflow:hidden;background:#020617}
  .bar>span{display:block;height:100%;width:0;transition:width .2s}
  .hp>span{background:linear-gradient(90deg,#ef4444,#b91c1c)}
  .exp>span{background:linear-gradient(90deg,#38bdf8,#0ea5e9)}
  .val{min-width:90px;text-align:right;opacity:.9;font-size:12px}

  /* QA: éš™é–“ã‚’åŸ‹ã‚ã‚‹ */
  #qaBox{display:flex;flex-direction:column;min-height:34vh}
  #question{margin:0 0 8px;font-size:20px;font-weight:700}
  #choices{flex:1;display:flex;flex-direction:column;gap:4px;min-height:0}

  button.choice{
    flex:1;
    min-height:52px;
    padding:12px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(17,24,39,.86);
    color:inherit;
    font-size:20px;
    font-weight:700;
    cursor:pointer;
  }
  button.choice:disabled{opacity:.55;cursor:default}

  /* æ¬¡ã¸ã‚¹ãƒ­ãƒƒãƒˆï¼šå¸¸ã«ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ï¼ˆvisibilityã§åˆ‡æ›¿ï¼‰ */
  #nextSlot{height:46px;display:flex;align-items:center}
  #nextBtn{
    padding:8px 14px;
    font-size:14px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(17,24,39,.86);
    color:inherit;
    cursor:pointer;

    visibility:hidden;
    pointer-events:none;
  }
  #nextBtn.show{visibility:visible;pointer-events:auto}

  #logWrap{min-height:96px;max-height:30vh;display:flex;flex-direction:column;padding-top:2px;background:rgba(0,0,0,.35);border-radius:8px}
  #log{flex:1;overflow:auto;font-size:13px;padding:4px 6px}
  #log p{margin:2px 0}
  .ok{color:var(--ok)}
  .bad{color:var(--bad)}
  .blink{animation:blink .24s 3}
  @keyframes blink{50%{filter:brightness(2)}}

  #enemyView img{display:block;width:100%;height:auto;max-height:30vh;object-fit:contain;opacity:.95}
</style>
</head>
<body>
<div id="wrap">
  <div id="topGrid">
    <section id="heroBox" class="panel compact">
      <div class="row"><span class="label">Lv</span><span id="lv">1</span></div>
      <div class="row"><span class="label">EXP</span><div class="bar exp"><span id="expBar"></span></div><span class="val" id="expText">0 / 20</span></div>
      <div class="row"><span class="label">HP</span><div class="bar hp"><span id="hpBar"></span></div><span class="val" id="hpText">30 / 30</span></div>
      <div class="row"><span class="label">ATK</span><span id="atk">5</span></div>
    </section>

    <section id="enemyBox" class="panel compact">
      <div class="row"><span class="label">ENEMY</span><span id="enemyName">â€”</span></div>
      <div class="row"><span class="label">HP</span><div class="bar hp"><span id="enemyHpBar"></span></div><span class="val" id="enemyHpText">0 / 0</span></div>
    </section>

    <section id="qaBox" class="panel">
      <p id="question">â€”</p>
      <div id="choices"></div>
      <div id="nextSlot"><button id="nextBtn">æ¬¡ã®æ•µ â–¶</button></div>
    </section>

    <section id="enemyView" class="panel">
      <img id="enemyImg" src="" alt="" onerror="this.style.display='none'" />
    </section>
  </div>

  <section id="logWrap" class="panel">
    <div id="log"></div>
  </section>
</div>

<script>
const $=id=>document.getElementById(id);
const KEY='midunohi.exam.exp'; // ç´¯è¨ˆEXP
const R=n=>(Math.random()*n)|0;
const clamp=(x,a,b)=>x<a?a:x>b?b:x;
const bar=(id,r)=>{const e=$(id); if(e) e.style.width=(100*clamp(r,0,1)).toFixed(1)+'%';};
const log=s=>{const e=$('log'); if(!e) return; e.insertAdjacentHTML('beforeend',`<p>${s}</p>`); e.scrollTop=e.scrollHeight;};
const showNext=f=>$('nextBtn').classList.toggle('show',!!f);

// ---- EXPæ›²ç·šï¼ˆã“ã“ã ã‘å¥½ã¿ã§èª¿æ•´ï¼‰ ----
const EXP0 = 20;         // Lv1->2 å¿…è¦EXP
const EXP_GROW = 1.35;   // å¿…è¦EXPæˆé•·ç‡

// fallback
const FALLBACK_WORDS=[
  {en:'increase',ja:'å¢—ãˆã‚‹ã€å¢—ã‚„ã™'},{en:'reduce',ja:'æ¸›ã‚‰ã™'},{en:'gather',ja:'é›†ã‚ã‚‹'},{en:'explore',ja:'æ¢ç´¢ã™ã‚‹'},
  {en:'defeat',ja:'æ‰“ã¡å€’ã™'},{en:'guard',ja:'å®ˆã‚‹'},{en:'release',ja:'è§£æ”¾ã™ã‚‹'},{en:'vanish',ja:'æ¶ˆãˆã‚‹'}
];
const FALLBACK_MONSTERS=[
  {id:'ash_wyrm',ja:'ã‚¢ãƒƒã‚·ãƒ¥ãƒ»ãƒ¯ãƒ¼ãƒ '},{id:'dust_lizard',ja:'ãƒ€ã‚¹ãƒˆãƒ»ãƒªã‚¶ãƒ¼ãƒ‰'},{id:'ember_golem',ja:'ã‚¨ãƒ³ãƒãƒ¼ãƒ»ã‚´ãƒ¼ãƒ¬ãƒ '},{id:'night_siren',ja:'ãƒŠã‚¤ãƒˆãƒ»ã‚µã‚¤ãƒ¬ãƒ³'}
];

let words=[], MONSTERS=[], enemy=null, Q=null;

const state={
  total:0,   // ç´¯è¨ˆEXPï¼ˆä¿å­˜ï¼‰
  lv:1, exp:0, nextExp:EXP0,
  maxHP:30, hp:30, atk:5,

  // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é †
  mi:0,
  // æ•µLvï¼šåˆæœŸã¯ max(1, lv-10)
  enemyLv:1,

  used:new Set()
};

function save(){ try{ localStorage.setItem(KEY, String(state.total)); }catch(e){} }

// ç´¯è¨ˆEXPã‹ã‚‰ (lv, exp, nextExp) ã‚’å¾©å…ƒï¼ˆå¿…è¦EXPãŒå¢—ãˆã‚‹æ–¹å¼ï¼‰
function recalcFromTotal(){
  let lv=1, next=EXP0, t=state.total;
  while(t >= next){
    t -= next;
    lv++;
    next = Math.round(next * EXP_GROW);
  }
  state.lv=lv; state.exp=t; state.nextExp=next;

  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆã“ã“ã‚‚å¥½ã¿ã§èª¿æ•´ï¼‰
  state.maxHP = 26 + state.lv*8;
  state.atk   = 5  + Math.floor(state.lv*1.2);
  state.hp = clamp(state.hp,0,state.maxHP);

  // æ•µLvã¯ã€Œæœ€å°ã§é©æ­£-10ã€ï¼šåˆæœŸå€¤ã¯å¸¸ã«ã“ã‚Œ
  state.enemyLv = Math.max(1, state.lv - 10);
}

function render(){
  $('lv').textContent=state.lv;
  $('atk').textContent=state.atk;
  $('hpText').textContent=`${state.hp} / ${state.maxHP}`;
  $('expText').textContent=`${state.exp} / ${state.nextExp}`;
  bar('hpBar', state.hp/state.maxHP);
  bar('expBar', state.exp/state.nextExp);
}

function gainExp(x){
  if(x<=0) return;
  const beforeLv=state.lv;

  state.total += x; save();
  recalcFromTotal();

  if(state.lv>beforeLv){
    const heal = Math.round(state.maxHP*0.35);
    state.hp = clamp(state.hp + heal, 0, state.maxHP);
    log(`<span class="ok">âœ¨ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv${beforeLv} â†’ Lv${state.lv}ï¼ˆ+${heal}HPï¼‰</span>`);
  }
  render();
}

async function loadMonsters(){
  try{
    const res=await fetch('img/monsters/monsters.js',{cache:'no-store'});
    if(!res.ok) throw 0;
    const t=await res.text();
    const i=t.indexOf('['), j=t.lastIndexOf(']');
    const arr=new Function(`return ${t.slice(i,j+1)}`)();
    if(!Array.isArray(arr) || !arr[0]?.id || !arr[0]?.ja) throw 0;
    MONSTERS=arr;
  }catch(e){ MONSTERS=FALLBACK_MONSTERS; }
}

function setEnemyImage(mon){
  const img=$('enemyImg');
  img.style.display='block';
  img.src=`img/monsters/${mon.id}.png`;
  img.alt=mon.ja;
  img.onerror=()=>img.style.display='none';
}

function updateEnemy(){
  $('enemyHpText').textContent=`${enemy.hp} / ${enemy.maxHP}`;
  bar('enemyHpBar', enemy.hp/enemy.maxHP);
}

// æ•µã®åˆæœŸå‡ºç¾Lvï¼šmax(1, lv-10)
// å€’ã™ã”ã¨ã« enemyLv++ï¼ˆãŸã ã—æœ€å¤§ã§ lv ã¾ã§ï¼‰
function spawnEnemy(){
  const mon = MONSTERS[state.mi % MONSTERS.length] || FALLBACK_MONSTERS[0];
  state.mi = (state.mi+1) % MONSTERS.length;

  const L = state.enemyLv;

  enemy={
    id:mon.id, name:mon.ja, level:L,
    maxHP: 18 + L*10,
    hp:    18 + L*10,
    atkMin: 3 + L*2,
    atkMax: 6 + L*3,
    xp: 6 + Math.floor(L*1.2)
  };

  $('enemyName').textContent=`${enemy.name} Lv${enemy.level}`;
  setEnemyImage(mon);
  updateEnemy();
  log(`ğŸ‘¾ Lv${enemy.level} ${enemy.name} ãŒç¾ã‚ŒãŸï¼`);
}

async function loadWords(){
  try{
    const c=await (await fetch('en_ja/categories.json',{cache:'no-store'})).json();
    const files=Array.isArray(c?.files)?c.files:[];
    if(!files.length) throw 0;
    const all=(await Promise.all(files.map(n=>fetch(`en_ja/${n}.json`,{cache:'no-store'}).then(r=>r.json())))).flat();
    if(!all.length || !('en'in all[0]) || !('ja'in all[0])) throw 0;
    words=all;
  }catch(e){ words=FALLBACK_WORDS; }
}

function shuffle(a){
  for(let i=a.length-1;i>0;i--){ const j=R(i+1); [a[i],a[j]]=[a[j],a[i]]; }
  return a;
}

function nextQuestion(){
  if(state.hp<=0){ $('question').textContent='â˜ ï¸ GAME OVER'; $('choices').innerHTML=''; showNext(false); return; }
  if(!words.length){ $('question').textContent='å˜èªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“'; $('choices').innerHTML=''; return; }

  const idxs=words.map((_,i)=>i).filter(i=>!state.used.has(i));
  if(!idxs.length){ state.used.clear(); return nextQuestion(); }

  const pick=idxs[R(idxs.length)];
  state.used.add(pick);
  const q=words[pick];

  const correct=q.en;
  const set=new Set([correct]);
  while(set.size<4 && set.size<words.length) set.add(words[R(words.length)].en);

  Q={ja:q.ja, ans:correct, ch:shuffle([...set])};

  $('question').textContent=`ã€Œ${Q.ja}ã€ã®è‹±èªã¯ï¼Ÿ`;
  const box=$('choices'); box.innerHTML='';
  Q.ch.forEach(w=>{
    const b=document.createElement('button');
    b.className='choice';
    b.textContent=w;
    b.onclick=()=>answer(w);
    box.appendChild(b);
  });
}

function playerDmg(){
  const base=state.atk;
  return base + R(1+Math.max(1,Math.floor(base*0.6)));
}
function recoilDmg(){
  const L=enemy.level;
  return (2+Math.floor(L*0.8)) + R(2+Math.floor(L*0.4));
}
function fatalWrongDmg(){
  const p = Math.round(state.maxHP*(0.55 + Math.min(0.20, enemy.level*0.01)));
  const e = enemy.atkMax*2;
  return Math.max(p,e) + R(1+Math.round(state.maxHP*0.10));
}

function disableChoices(){
  document.querySelectorAll('button.choice').forEach(b=>b.disabled=true);
}

function answer(choice){
  if(!Q || !enemy || state.hp<=0) return;
  disableChoices();

  if(choice===Q.ans){
    const d=playerDmg();
    enemy.hp=clamp(enemy.hp-d,0,enemy.maxHP);
    log(`âœ… æ­£è§£ï¼ <span class="ok">${d} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
    updateEnemy();

    const self=recoilDmg();
    state.hp=clamp(state.hp-self,0,state.maxHP);
    log(`ğŸ’¥ åå‹•ï¼ <span class="bad">${self} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
  }else{
    const d=fatalWrongDmg();
    state.hp=clamp(state.hp-d,0,state.maxHP);
    log(`âŒ ä¸æ­£è§£â€¦ <span class="bad">${d} ãƒ€ãƒ¡ãƒ¼ã‚¸</span>`);
  }

  render();

  if(state.hp<=0){
    log(`<span class="bad">â˜ ï¸ å€’ã‚ŒãŸâ€¦</span>`);
    nextQuestion();
    return;
  }

  if(enemy.hp<=0){
    const heal=Math.round(state.maxHP*0.18)+2;
    state.hp=clamp(state.hp+heal,0,state.maxHP);
    log(`ğŸ† æ’ƒç ´ï¼ <span class="ok">+${enemy.xp} EXP</span> / <span class="ok">+${heal}HP</span>`);

    // æ•µLvã‚’ä¸Šã’ã‚‹ï¼ˆæœ€å¤§ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Lvã¾ã§ï¼‰
    state.enemyLv = state.enemyLv + 1;

    render();
    gainExp(enemy.xp);
    showNext(true);
    return;
  }

  setTimeout(nextQuestion, 180);
}

function nextEnemy(){
  showNext(false);
  spawnEnemy();
  nextQuestion();
}

function init(){
  state.total = Number(localStorage.getItem(KEY) || '0');
  if(!Number.isFinite(state.total) || state.total<0) state.total=0;

  recalcFromTotal();
  state.hp = state.maxHP; // HPã¯é–‹å§‹æ™‚å…¨å¿«ï¼ˆä¿å­˜ã—ãªã„ï¼‰
  render();

  loadMonsters().then(()=>{
    const idx = MONSTERS.findIndex(m=>m?.id==='dust_lizard');
    state.mi = idx>=0 ? idx : 0;

    loadWords().then(()=>{
      spawnEnemy();
      nextQuestion();
      $('nextBtn').onclick=nextEnemy;
    });
  });
}

init();
</script>
</body>
</html>