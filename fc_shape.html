<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcards: Shapes (fc_shape)</title>
  <style>
    :root{ --bg:#0f172a; --card:#111827; --fg:#e5e7eb; --muted:#9ca3af; --accent:#22d3ee; --accent2:#60a5fa; }
    html,body{height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; background: radial-gradient(60rem 60rem at 50% -10%, #0b1220 0%, var(--bg) 40%, #070b14 100%);}    
    .container{max-width:980px; margin:0 auto; padding:16px 16px 40px;}

    /* HUD (progress gauge) */
    .hud{display:grid; grid-template-columns:1fr auto; align-items:center; gap:14px; margin:6px 2px 8px}
    .gauge{position:relative; height:12px; background:#0b1220; border:1px solid #1f2937; border-radius:999px; overflow:hidden}
    .gauge-fill{position:absolute; inset:0; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent2)); box-shadow:0 0 12px rgba(96,165,250,.35) inset; transition:width .35s ease}
    .gauge-text{color:var(--fg); font-weight:700; letter-spacing:.3px}
    .gauge-sub{color:var(--muted); font-size:12px; margin-left:8px}

    .card{margin-top:10px; background:linear-gradient(180deg,#0a1322,#0a0f1a); border:1px solid #1f2937; border-radius:20px; padding:24px; display:grid; grid-template-columns:1.2fr 1fr; gap:16px; align-items:flex-start; box-shadow:0 10px 30px rgba(0,0,0,.35); cursor:pointer; user-select:none}
    .left{display:flex; flex-direction:column; gap:16px;}
    .term{font-size:32px; line-height:1.2; color:var(--fg); font-weight:800;}
    .muted{color:var(--muted); font-size:13px}
    .phrases{display:flex; flex-direction:column; gap:8px;}
    .phrase-line{display:flex; gap:12px; align-items:baseline;}
    .phrase-en{color:var(--fg); font-size:16px;}
    .phrase-ja{color:var(--muted); font-size:16px;}
    .shape{display:flex; justify-content:center; align-items:center; background:#0b1220; border:1px dashed #243043; border-radius:16px; padding:12px;}
    .shape svg{ width: clamp(180px, 44vw, 360px); height: auto; overflow: visible; }
    @media (max-width:720px){
      .card{grid-template-columns:1fr; padding:20px}
      .term{font-size:26px}
      .shape svg{ width: clamp(160px, 72vw, 340px); height:auto; }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- HUD: progress gauge -->
    <div class="hud" aria-live="polite" aria-label="進捗">
      <div class="gauge" aria-hidden="true"><div class="gauge-fill" id="gfill"></div></div>
      <div class="gauge-text"><span id="gcount">0</span> / <span id="gtotal">0</span><span class="gauge-sub" id="glaps"></span></div>
    </div>

    <section class="card" aria-live="polite" id="card">
      <div class="left">
        <div class="term" id="term">circle</div>
        <div class="muted">クリック / スペース / Enter / → で 「解答表示 → 次カード」</div>
        <div class="phrases" id="phrases"></div>
      </div>
      <div class="shape" id="shape"></div>
    </section>
  </div>
  <a href="index.html">戻る</a>

  <script>
  // ===== Utilities =====
  const TAU = Math.PI*2;
  function el(svg, name, attrs){ const n = document.createElementNS('http://www.w3.org/2000/svg', name); for(const k in attrs) n.setAttribute(k, attrs[k]); svg.appendChild(n); return n; }
  function poly(svg, pts, stroke){ return el(svg,'polygon',{points: pts.map(([x,y])=>`${x},${y}`).join(' '), fill:'none', stroke, 'stroke-width':10, 'stroke-linejoin':'round'}); }
  function line(svg,x1,y1,x2,y2,stroke){ return el(svg,'line',{x1,y1,x2,y2,stroke,'stroke-width':10,'stroke-linecap':'round'}); }
  function txt(svg,x,y,text,fill='#e5e7eb',size=28){ const t=el(svg,'text',{x,y,fill,'font-size':size,'font-family':'system-ui,Segoe UI,Roboto,sans-serif','text-anchor':'middle','dominant-baseline':'middle'}); t.textContent=text; return t; }
  function pointsRegularPolygon(cx,cy,r,n,rot=-Math.PI/2){ const pts=[]; for(let i=0;i<n;i++){ const a=rot+i*TAU/n; pts.push([cx+r*Math.cos(a), cy+r*Math.sin(a)]);} return pts; }

  // ===== Base Shape Drawers =====
  const draw = {
    circle:(svg,cx=110,cy=110,r=80,stroke='#22d3ee')=>el(svg,'circle',{cx,cy,r,fill:'none',stroke,'stroke-width':10}),
    ellipse:(svg,cx=110,cy=110,rx=90,ry=60,stroke='#22d3ee')=>el(svg,'ellipse',{cx,cy,rx,ry,fill:'none',stroke,'stroke-width':10}),
    rect:(svg,x=40,y=40,w=140,h=140,stroke='#60a5fa',rx=8)=>el(svg,'rect',{x,y,width:w,height:h,fill:'none',stroke,'stroke-width':10,rx,ry:rx}),
    polygon:(svg,n,stroke='#f59e0b',r=90)=>poly(svg,pointsRegularPolygon(110,110,r,n),'#f59e0b'),
    star5:(svg,stroke='#f472b6')=>{ // 5-point star
      const outer=pointsRegularPolygon(110,110,90,5,-Math.PI/2);
      const inner=pointsRegularPolygon(110,110,40,5,-Math.PI/2+TAU/10);
      const pts=[]; for(let i=0;i<5;i++){ pts.push(outer[i], inner[i]); }
      poly(svg,pts,stroke);
    },
    triangleKinds:{
      equilateral:(svg)=>poly(svg,pointsRegularPolygon(110,120,85,3,-Math.PI/2),'#f472b6'),
      isosceles:(svg)=>poly(svg,[[110,30],[170,190],[50,190]],'#f472b6'),
      right:(svg)=>poly(svg,[[30,190],[30,60],[190,190]],'#f472b6'),
      scalene:(svg)=>poly(svg,[[40,180],[180,170],[90,40]],'#f472b6')
    },
    parallelogram:(svg)=>{ poly(svg,[[40,160],[160,160],[200,70],[80,70]],'#34d399'); },
    trapezoid:(svg)=>{ poly(svg,[[50,170],[170,170],[200,90],[20,90]],'#34d399'); },
    rhombus:(svg)=>{ poly(svg,[[110,20],[200,110],[110,200],[20,110]],'#34d399'); },
    kite:(svg)=>{ poly(svg,[[110,20],[160,110],[110,200],[60,110]],'#34d399'); }
  };

  // ===== Card Builders (problem types) =====
  function cardName(en,ja,drawFn){ return { en, ja, phrases:[{en:`This is a ${en}.`, ja:`これは${ja}です。`}], draw:drawFn }; }
  function cardCountSides(n, drawFn){ const en='How many sides does this shape have?'; const ja='この図形の辺はいくつ？'; const ansEn=(n===Infinity? 'infinitely many' : n)+(n===1? ' side':' sides'); const ansJa=(n===Infinity? '無数' : n+'辺'); return { en, ja, phrases:[{en:`It has ${ansEn}.`, ja:`${ansJa}です。`}], draw:drawFn }; }
  function cardCountVertices(n, drawFn){ const en='How many vertices does this shape have?'; const ja='この図形の頂点はいくつ？'; return { en, ja, phrases:[{en:`It has ${n} vertices.`, ja:`${n}個の頂点です。`}], draw:drawFn }; }
  function cardSymmetry(n, drawFn){ const en='How many lines of symmetry?'; const ja='対称軸はいくつ？'; const ansEn=n===Infinity? 'infinitely many':String(n); const ansJa=n===Infinity? '無数':`${n}本`; return { en, ja, phrases:[{en:`There are ${ansEn}.`, ja:`${ansJa}あります。`}], draw:drawFn }; }
  function cardAngleSum(n, drawFn){ const sum=(n-2)*180; const en='Sum of interior angles?'; const ja='内角の和は？'; return { en, ja, phrases:[{en:`${sum}°`, ja:`${sum}度`}], draw:drawFn }; }
  function cardClassifyTriangle(kind, drawFn){ const map={equilateral:['equilateral triangle','正三角形'], isosceles:['isosceles triangle','二等辺三角形'], right:['right triangle','直角三角形'], scalene:['scalene triangle','不等辺三角形']}; const [enName, jaName]=map[kind]; return { en:'Classify this triangle.', ja:'この三角形の種類は？', phrases:[{en:enName, ja:jaName}], draw:drawFn }; }
  function cardPerimeterCompare(drawFn){ return { en:'Which has a longer perimeter: A or B?', ja:'周長が長いのは A と B のどちら？', phrases:[{en:'A is longer.', ja:'A の方が長い。'},{en:'B is longer.', ja:'B の方が長い。'}], draw:drawFn }; }
  function cardAreaCompare(drawFn){ return { en:'Which has a larger area: A or B?', ja:'面積が大きいのは A と B のどちら？', phrases:[{en:'A has a larger area.', ja:'A の方が大きい。'},{en:'B has a larger area.', ja:'B の方が大きい。'}], draw:drawFn }; }

  // ===== Build dataset =====
  const data = [];
  // (A) Name the shape (基本図形認識)
  data.push(
    cardName('circle','円',(svg)=>draw.circle(svg)),
    cardName('ellipse','楕円',(svg)=>draw.ellipse(svg)),
    cardName('triangle','三角形',(svg)=>draw.triangleKinds.equilateral(svg)),
    cardName('square','正方形',(svg)=>draw.rect(svg,40,40,140,140)),
    cardName('rectangle','長方形',(svg)=>draw.rect(svg,30,60,160,120)),
    cardName('pentagon','五角形',(svg)=>draw.polygon(svg,5)),
    cardName('hexagon','六角形',(svg)=>draw.polygon(svg,6)),
    cardName('octagon','八角形',(svg)=>draw.polygon(svg,8)),
    cardName('parallelogram','平行四辺形',draw.parallelogram),
    cardName('trapezoid','台形',draw.trapezoid),
    cardName('rhombus','ひし形',draw.rhombus),
    cardName('kite','凧形',draw.kite),
    cardName('star','星形',draw.star5)
  );

  // (B) Count sides / vertices（属性の数え上げ）
  data.push(
    cardCountSides(Infinity,(svg)=>draw.circle(svg)), // circle: infinitely many
    cardCountSides(3,(svg)=>draw.triangleKinds.isosceles(svg)),
    cardCountVertices(3,(svg)=>draw.triangleKinds.scalene(svg)),
    cardCountSides(4,(svg)=>draw.rect(svg,40,40,140,140)),
    cardCountVertices(4,(svg)=>draw.rect(svg,30,60,160,120)),
    cardCountSides(5,(svg)=>draw.polygon(svg,5)),
    cardCountSides(6,(svg)=>draw.polygon(svg,6)),
    cardCountVertices(8,(svg)=>draw.polygon(svg,8))
  );

  // (C) Symmetry（対称性）
  data.push(
    cardSymmetry(Infinity,(svg)=>draw.circle(svg)),
    cardSymmetry(4,(svg)=>draw.rect(svg,40,40,140,140)),
    cardSymmetry(2,(svg)=>draw.rect(svg,30,60,160,120)),
    cardSymmetry(3,(svg)=>draw.triangleKinds.equilateral(svg))
  );

  // (D) Angle sum（内角の和）
  data.push(
    cardAngleSum(3,(svg)=>draw.triangleKinds.equilateral(svg)), // 180
    cardAngleSum(5,(svg)=>draw.polygon(svg,5)), // 540
    cardAngleSum(6,(svg)=>draw.polygon(svg,6))  // 720
  );

  // (E) Classify triangle（三角形の分類）
  data.push(
    cardClassifyTriangle('equilateral',draw.triangleKinds.equilateral),
    cardClassifyTriangle('isosceles',draw.triangleKinds.isosceles),
    cardClassifyTriangle('right',draw.triangleKinds.right),
    cardClassifyTriangle('scalene',draw.triangleKinds.scalene)
  );

  // (F) Perimeter compare / Area compare（大小比較）
  data.push(
    cardPerimeterCompare((svg)=>{ // two polygons A,B
      draw.rect(svg,10,40,110,110,'#60a5fa'); txt(svg,65,25,'A');
      draw.rect(svg,130,60,90,140,'#60a5fa'); txt(svg,175,25,'B');
    }),
    cardAreaCompare((svg)=>{
      draw.polygon(svg,6,'#f59e0b',78); txt(svg,70,28,'A');
      draw.polygon(svg,5,'#f59e0b',88); txt(svg,160,28,'B');
    })
  );

  // ===== State & Elements =====
  let idx = 0;           // which card
  let revealed = false;  // false: show only English, true: show translations
  let solved = 0;        // number of answers revealed (ゲージ用)

  const termEl    = document.getElementById('term');
  const phrasesEl = document.getElementById('phrases');
  const shapeEl   = document.getElementById('shape');
  const cardEl    = document.getElementById('card');
  const gfillEl   = document.getElementById('gfill');
  const gcountEl  = document.getElementById('gcount');
  const gtotalEl  = document.getElementById('gtotal');
  const glapsEl   = document.getElementById('glaps');

  gtotalEl.textContent = String(data.length);

  // ===== Render & interaction =====
  function render(){
    const item = data[idx];
    termEl.textContent = revealed ? `${item.en} — ${item.ja}` : item.en; // em-dash形式

    // phrases
    phrasesEl.innerHTML = '';
    item.phrases.forEach(p=>{
      const line = document.createElement('div');
      line.className = 'phrase-line';
      const en = document.createElement('div'); en.className='phrase-en'; en.textContent = p.en;
      line.appendChild(en);
      if(revealed){
        const ja = document.createElement('div'); ja.className='phrase-ja'; ja.textContent = p.ja; line.appendChild(ja);
      }
      phrasesEl.appendChild(line);
    });

    // shape
    shapeEl.innerHTML='';
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('viewBox','-6 -6 232 232');
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');
    shapeEl.appendChild(svg);
    item.draw(svg);
  }

  function updateGauge(){
    const total = data.length;
    const clamped = Math.min(solved, total);
    const pct = Math.round((clamped/total)*100);
    gcountEl.textContent = String(clamped);
    gfillEl.style.width = pct + '%';
    const laps = solved>total ? Math.floor((solved-1)/total) : 0;
    glapsEl.textContent = laps>0 ? `（周回 ${laps}）` : '';
  }

  function advance(){
    if(!revealed){
      // Reveal answer → progress ++
      revealed = true;
      solved++;
      updateGauge();
      render();
    }else{
      // Next card
      revealed = false;
      idx = (idx+1)%data.length;
      render();
    }
  }

  cardEl.addEventListener('click', advance, {passive:true});
  window.addEventListener('keydown', (e)=>{ if(e.key===' '|| e.key==='Enter' || e.key==='ArrowRight'){ e.preventDefault(); advance(); } });

  // Initial paint
  render();
  updateGauge();

  // ===== Simple Tests (console) =====
  (function runTests(){
    console.groupCollapsed('%cfc_shape tests','color:#22d3ee');
    try{
      console.assert(revealed===false, 'initial revealed=false');
      console.assert(!/—/.test(document.getElementById('term').textContent), 'initial term has no Japanese');
      console.assert(Array.isArray(data) && data.length>=24, 'has many problem types (>=24 cards)');
      const startWidth = parseFloat(getComputedStyle(document.getElementById('gfill')).width);
      advance();
      console.assert(/—/.test(document.getElementById('term').textContent), 'term shows Japanese when revealed');
      const afterWidth = parseFloat(getComputedStyle(document.getElementById('gfill')).width);
      console.assert(afterWidth > startWidth, 'gauge progressed on reveal');
      const prevIdx = idx; advance();
      console.assert(idx === (prevIdx+1)%data.length, 'moves to next card');
      console.assert(document.getElementById('shape').querySelector('svg').childElementCount>0, 'shape rendered');
      console.log('All tests passed.');
    }catch(err){ console.error('Test failure:', err); }
    finally{ console.groupEnd(); }
  })();
  </script>
</body>
</html>
